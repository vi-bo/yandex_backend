## Deploy часть 1.

Первоисточник: [Девопс, деплой, CI/CD. Часть 1 - YouTube](https://www.youtube.com/watch?v=5llOsvi7xeM)

> **ПОЛЕЗНЫЕ КОМАНДЫ:**
> 
> `docker ps` # проверка запущенных контейнеров
> 
> `docker ps -a` # список закрытых контейнеров
> 
> `docker exec -it номер_контейнера bash` # подключение к контейнеру
> 
> `make docker-build` # сборка контейнера
> 
> `make docker-run` # запуск контейнера
> 
> `docker rm -f имя_контейнера` # удаление контейнера
> 
> `docker inspect` # номер_контейнера
> 
> `gzip --keep --force -9 Имя_файла` # сжимаем файл
> 
> `gunzip -c Имя_файла.gz` # просмотр сжатого файла
> 
> `ps aux` # список запущенных процессов
> 
> `systemctl -a` # все сервисы на linux
> 
> `tree -L 3` # дерево каталога
> 
> `la -al` # вывод полной информации о папке
> 
> `exit` # выход из контейнера docker
> 
> `docker images` # проверяем, что приложение запустилось
> 
> `kill -9 номер_PID` # отключим приложение
> 
> `systemctl status имя_сервиса` # проверка запуска сервиса
> 
> `sudo systemctl start имя_сервиса` # запуск сервиса
> 
> `sudo systemctl daemon-reload`#обновление данных о сервисах

**План лекции:**

1. Как начинают программировать  (часть 1.)

2. Упаковка (часть 1.)

3. Доставка (часть 1.)

4. Запуск (часть 1.)

5. Утилизация ресурсов (часть 2.)

6. Системы оркестрации (часть 2.)

7. CI/CD (часть 2.)

### 1. Как начинают программировать

#### Типичный деплой типичного сайта

1. Одна машина;

2. Не нужно перезапускать процессы;

3. Нет SLA;

4. Нет требования к атомарности изменений;

5. Зависимости копируются вместе с кодом;

6. Упарвление системными зависимостями происходит через некий внешний интерфейс.

#### DevOps

<img src="file:///home/vibo/Pictures/GlobalMarkText/2022-08-19-13-37-48-image.png" title="" alt="" data-align="center">

1. Сокращается время на взаимодецствие между командами;

2. Большая вовлеченность в процесс эксплуатации -> рост качества кода;

3. Возможность быстрых экспериментов над продуктом (time to market).

<img src="file:///home/vibo/Pictures/GlobalMarkText/2022-08-19-13-43-37-image.png" title="" alt="" data-align="center">

На "не лекции" будем рассматривать ops в разрезе бекенд-разработки!

**CMS (Content Management System)** - система для управления контентом. Самым ярким представителей является WordPress (устанавливаем и можем создавать странички, наполнять их и управлять).

**SLA (Service Level Agreement)** - соглашение о доступности сервиса (соглашение о том, сколько сервис может не отвечать в единицах времени в год, в месяц и т.д.)

#### Приложения с которыми будем работать

Приложение на Python, см. https://github.com/grigory51/shbr-devops

Файл main.py. Есть две ручки, берем содержимое этих ручек и росто отдаем, то, что нам прислали. Еще добавляем префикс к содержимому url - 'python', чтобы понять, какое приложение нам ответило. 

```python
from aiohttp import web
import os


async def handle(request):
    name = request.match_info.get('name', "")
    return web.Response(text=f'{os.getenv("PREFIX", "")}{name}',
                        headers={'X-Shbr-Lang': 'python'})


app = web.Application()
app.add_routes([
    web.get('/', handle),
    web.get('/{name}', handle)
])

if __name__ == '__main__':
    web.run_app(app, host=os.getenv('HOST', '0.0.0.0'), port=int(os.getenv('PORT', 10000)))
```

Переходим к основным этапам эксплуатации приложения.

### 2. Упаковка

**Варианты упаковки:**

- пакеты (.deb, .rpm)
- docker-контейнеры

#### 2.1. Пакеты (.deb, .rpm)

`cd 01-package-deb` # идем в папку

`ls` # смотрим содержимое

```bash
build  Dockerfile  hint.sh  Makefile
```

Все манипуляции выполняем в докере (заранее подготовлен).

`make docker-run` # запускаем контейнер

```
docker run -it cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-deb:latest
shbr@8cc69dfb768b:/shbr-echo$
```

`ls` # смотрим содержимое

```bash
build  hint.sh  java  python
```

##### Структура проекта

`tree -L 3` # смотрим на дерево каталога

```bash
.
|-- build # в папке build основные скрипты для сборки
|   |-- build.sh
|   |-- clean.sh
|   |-- debian # папка debian с метафайлами
|   |   |-- changelog
|   |   |-- compat
|   |   |-- control
|   |   `-- rules
|   `-- install.sh
|-- hint.sh
|-- java # папка с проектом на java
|   |-- build.gradle
|   |-- gradle
|   |   `-- wrapper
|   |-- gradlew
|   |-- gradlew.bat
|   |-- settings.gradle
|   `-- src
|       |-- main
|       `-- test
`-- python # папка с проектом на python
    `-- main.py
```

`cd build/debian` # посмотрим на метафайлы 

`ls -al`

```bash
total 16
drwxr-xr-x 1 shbr shbr  54 Aug 11 14:16 .
drwxr-xr-x 1 shbr shbr  64 Aug 11 14:18 ..
-rwxr-xr-x 1 shbr shbr 141 Jul 13  2021 changelog
-rwxr-xr-x 1 shbr shbr   1 Jul 13  2021 compat
-rwxr-xr-x 1 shbr shbr 292 Jul 28 15:03 control
-rwxr-xr-x 1 shbr shbr 192 Jul 13  2021 rules
```

 Это минимальный набор для сборки пакета.

###### Файл control

`cat control` # просмотр содержимого файла control

Здесь лежат заголовочные мета-данные, которые описывают пакет и его зависимости. Здесь указано название пакета, как мы его назовем, указаны зависимости. Например, для этого пакета нам нужны  build-essential, debhelper и java17. Также здесь указывается Maintainer - обязательное поле, чтобы можно было связаться с автором пакета, Architecture и другие опции.

    Source: shbr-echo
    Section: devel
    Priority: optional
    Maintainer: Grigory Ozhegov <ozhegov@yandex-team.ru>
    Build-Depends: build-essential, debhelper (>= 9), oracle-java17-installer
    
    Package: shbr-echo
    Architecture: amd64
    Depends: ${shlibs:Depends}, ${misc:Depends}
    Description: shbr echo server

###### Файл rules

`cat rules`

Это make-файл в котором описываются этапы сборки пакета. Их огромное количество, а это минимальный набор, который состоит из очистки, сборки и установки. Эта команда запускается после сборки пакета, т.е все дополнителньые артефакты, которые были созданы в процессе сборки удаляются, для экономии места на диске. Этап build запускается, чтобы исходные код превратить в файлы, которые можно запустить. Для python здесь может быть создание виртуального окружения и установка библиотек. Для java - сборка jar-архива.

```bash
#!/usr/bin/make -f

PKGDIR=debian/tmp

%:
    dh $@

override_dh_auto_clean:
    ./clean.sh
override_dh_auto_build:
    ./build.sh

override_dh_auto_install:
    env DESTDIR=debian/shbr-echo ./install.sh
```

###### Файл install.sh

Последний этап это install.sh (установка). Посмотрим как выглядит скрипт.

 `cat install.sh`

```bash
#!/bin/bash
set -e

mkdir -p "$DESTDIR/usr/bin/"

cp libs/java-0.0.1-SNAPSHOT.jar "$DESTDIR/usr/bin/shbr-echo.jar"
cp main.py "$DESTDIR/usr/bin/shbr-echo.py"
```

При сборке пакета мы генерируем директорию, которая выступает в качестве виртуального корня нашей файловой системы (DESTDIR=debian/shbr-echo). Хотим, чтобы наше приложение оказалось в папке usr/bin/. Цель файла install.sh в том, чтобы разложить файлы так, как будто они лежат на файловой системе. `cp` - копирование файлов в сборочные дирректории.

###### Файл compat

Файл, позволяющий обеспечить совместитость с системой сборки. В следующих версиях ubuntu понимает такие опции доступны при сборке пакета, а какие нет.

`cat compat` 

    9

###### Файл changelog

`cat changelog` 

Здесь дописываются все изменения версии пакета. Т.е. когда будем менять паке, добавлять новую версию пакета - сюда дописываем, что у нас изменилось.  Соответственно тут можно проследить, что происходило с кодом.

    shbr-echo (1.0.0-1) stretch; urgency=medium
    
      * First version
    
     -- Grigory Ozhegov <ozhegov@yandex-team.ru>  Fri, 25 Jun 2021 03:22:41 +0300

###### Файл clean.sh

`cat clean.sh` 

Удаляем дирректорию, которая является виртуальным деревом.

    #!/bin/bash
    set -e

###### Файл build.sh

`cat build.sh` 

Файл запускает сборку нашего кода. В случае с java - мы используем gradlew и запускаем наш bootJar, а в случае с python - мы копируем main.py туда, где будет установлено наше приложение.

    #!/bin/bash
    set -ex
    
    ../java/gradlew bootJar -p ../java -PbuildDir=$(pwd)    
    cp ../python/main.py ./shbr

##### Cборка deb-пакета

В файле hint.sh - подсказки, чтобы не вспоминать флаги.

`cat hint.sh`

```bash
#!/bin/bash

cd build
dpkg-buildpackage -b --no-sign >/dev/null 2>&1
```

Переходим в папку build и запустим команду:

`dpkg-buildpackage -b --no-sign`

Идет процесс сборки пакета: утилита читает файлы из папки debian, выводится информация о названии пакета и т.д., последовательно запускаются этапы чистки, сборки, побежал gradlew компилировать наше приложение на java, скопировался питонячий файлик - main.py.  После чего раскладываем файлики так, как бы они лежали на нашей файловой системе. После этого начал собираться сам пакет.

ПАКЕТ ПРЕДСТАВЛЯЕТ СОБОЙ АРХИВ С НЕКОЙ МЕТА-ИНФОРМАЦИЕЙ, КОТОРУЮ МОЖНО ВЕРСИОНИРОВАТЬ, СКАЧИВАТЬ С ПОМОЩЬЮ РАЗНЫХ ИНСТРУМЕНТОВ. ОБЫЧНЫЙ АРХИВ ТАКОЙ ВОЗМОЖНОСТИ НЕ ДАЕТ.

Проверим, что в корневой дирректории появился deb-пакет.

`ls`

```bash
build    java    shbr-echo_1.0.0-1_amd64.buildinfo  shbr-echo_1.0.0-1_amd64.deb
hint.sh  python  shbr-echo_1.0.0-1_amd64.changes
```

##### Установка deb-пакета

Теперь проверим, что в нашей папке bin нет этого установленного пакета.

`ls /usr/bin/sh*`

```bash
/usr/bin/sh         /usr/bin/sha256sum  /usr/bin/shasum
/usr/bin/sha1sum    /usr/bin/sha384sum  /usr/bin/shred
/usr/bin/sha224sum  /usr/bin/sha512sum  /usr/bin/shuf
```

Поставим наш пакет, от root

`sudo dpkg -i shbr-echo_1.0.0-1_amd64.deb`

```bash
Selecting previously unselected package shbr-echo.
(Reading database ... 24861 files and directories currently installed.)
Preparing to unpack shbr-echo_1.0.0-1_amd64.deb ...
Unpacking shbr-echo (1.0.0-1) ...
Setting up shbr-echo (1.0.0-1) ...
```

После запуска произошло разархивирование и раскладывание файликов по файловой системе. Также deb-пакеты позволяют выполнить различные действия во время установки. И действия для удаления. Видим, что у нас появились два приложения ***shbr-echo.jar*** и **shbr-echo.py**, которые мы установили с помощью нашего deb-пакета.

`ls /usr/bin/sh*`

```bash
/usr/bin/sh         /usr/bin/sha384sum      /usr/bin/shbr-echo.py
/usr/bin/sha1sum    /usr/bin/sha512sum      /usr/bin/shred
/usr/bin/sha224sum  /usr/bin/shasum         /usr/bin/shuf
/usr/bin/sha256sum  /usr/bin/shbr-echo.jar
```

Важно! С помощью докера мы в контейнере создали отдельную изолированную среду с операционной системой ubuntu. Поднимемся на уровень выше и перейдем в папку info.

`cd /var/lib/dpkg/info`

Здесь огромное количество файлов от разных пакетов. Все это имена пакетов. Пакеты можно различать по суфиксам (перед установкой, после установки и т.д.), например:

```bash
unattended-upgrades.postinst # после установки пакета
unattended-upgrades.postrm # после удаления пакета
unattended-upgrades.preinst # перед установкой пакета
unattended-upgrades.prerm # перед удалением пакета
```

В этих файлах можно проверить процесс установки. Бывает, что пакет устанавливается, но устанавливается с ошибкой, например postinst exit-1. Один из способов дебага - посмотреть данный файл.

 Пакет собран, приложения установлены, выходим.

`exit` # выход

#### 2.2. Контейнеры

В случае с реализацией контейнерной установки у нас есть так называемый докер-файл. Переходим в следующую папку с подготовленныйми файлами.

`cd 01-package-docker` 

`ls` 

```bash
Dockerfile  entrypoint.sh  Makefile
```

##### Dockerfile

Смотрим заранее приготовленный докер-файл для нашего приложения.

`cat Dockerfile`

```bash
#vibo: изначальный образ, так же как в пакете, сложная файловая система, запакованная
#vibo: в архив, она разделена на слои и каждый слой добавляет файлы в файловую систему
#vibo: берем образ
FROM cr.yandex/crpamim8dasm0u97qtpf/shbr-projects:latest as builder
#vibo: переходим в папку
WORKDIR /shbr-echo
#vibo: установка базовых пакетов
RUN apt-get update
RUN DEBIAN_FRONTEND="noninteractive" apt-get install -y software-properties-common
# установка java
# установка JDK
RUN add-apt-repository ppa:linuxuprising/java
RUN apt-get update
RUN /bin/echo debconf shared/accepted-oracle-license-v1-3 select true | /usr/bin/debconf-set-selections
RUN /bin/echo debconf shared/accepted-oracle-license-v1-3 seen true | /usr/bin/debconf-set-selections
RUN DEBIAN_FRONTEND="noninteractive" apt-get install -y oracle-java17-installer
#vibo: запускаем сборку java
RUN java/gradlew bootJar -p ./java
#vibo: второй фром для Python; в докере может быть несколько таких секций, но финальная та, которая будет последней.
#vibo: берем базовую убунту в которой нет ничего
FROM ubuntu:focal
# установка базовых пакетов
RUN apt-get update
RUN DEBIAN_FRONTEND="noninteractive" apt-get install -y software-properties-common
# установка Python
RUN DEBIAN_FRONTEND="noninteractive" apt-get install -y python3 python3-pip
#vibo: для питона ставим aiohttp
RUN pip3 install aiohttp
# установка JDK
RUN add-apt-repository ppa:linuxuprising/java
RUN apt-get update
RUN /bin/echo debconf shared/accepted-oracle-license-v1-3 select true | /usr/bin/debconf-set-selections
RUN /bin/echo debconf shared/accepted-oracle-license-v1-3 seen true | /usr/bin/debconf-set-selections
RUN DEBIAN_FRONTEND="noninteractive" apt-get install -y oracle-java17-installer

RUN apt-get autoremove -y \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/* \
    && rm -rf /var/cache/* \
    && rm -rf /var/log/apt\
    && rm -rf /root/.cache
#vibo: как и в deb-пакетах копируем файлы, раскладывая их по заданным путям
COPY --from=builder /shbr-echo/java/build/libs/java-0.0.1-SNAPSHOT.jar /shbr-echo.jar
COPY --from=builder /shbr-echo/python/main.py /shbr-echo.py
#vibo: добавляем файлы, меняем права
ADD entrypoint.sh /entrypoint.sh
RUN chmod a+x /entrypoint.sh

EXPOSE 10000
#vibo: устанавливаем переменную окружения
ENV LANG=python
#vibo: указываем команду, которая запустится после запуска контейнера
CMD ["/entrypoint.sh"]%
```

ЕСЛИ ПРИ ФОРМИРОВАНИИ ПАКЕТА ЭТА ПРОЦЕДУРА БЫЛА ОПИСАНА В РАЗНЫХ ФАЙЛАХ, ДЛЯ ДОКЕР-КОНТЕЙНЕРА ВСЕ СОБРАНО В ОДИН ФАЙЛ.

##### Сборка контейнера

В папке заранее заготовлены короткие команды для запуска (см .файл Makefile):

```bash
docker-build:
    docker build -t cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest .
docker-run:
    docker run -it cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest /bin/bash
docker-push:
    docker push cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest 
```

`make docker-build`

Соответственно выполняется команда `docker build -t cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest .`

В этот момент мы вызываем docker, метод build, говорим, что пакет будет называться так и ставим точку, обозначая текущую дирректорию. Итог выполнения на экране:

```bash
...
Successfully built f776beedde45
Successfully tagged cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest
```

##### Запуск контейнера

`make docker-run`

В этот момент выполняется команда `docker run -it cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest /bin/bash`. Контейнер запустился, результат на экране.

    docker run -it cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest /bin/bash

Посмотрим, что внутри контейнера.

`ls`

```bash
bin  boot  dev  entrypoint.sh  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  shbr-echo.jar  shbr-echo.py  srv  sys  tmp  usr  var
```

Контейнер представляет собой операционную систему внутри операционной системы. Т.е. у нас не просто раскладка файлов, а слепок системы как он был бы в реальной ubuntu.

`ls -la`

```bash
total 17108
drwxr-xr-x   1 root root      250 Aug 19 13:07 .
drwxr-xr-x   1 root root      250 Aug 19 13:07 ..
-rwxr-xr-x   1 root root        0 Aug 19 13:07 .dockerenv
lrwxrwxrwx   1 root root        7 Aug  1 13:22 bin -> usr/bin
drwxr-xr-x   1 root root        0 Apr 15  2020 boot
drwxr-xr-x   5 root root      360 Aug 19 13:07 dev
-rwxrwxr-x   1 root root      215 Aug 11 15:22 entrypoint.sh
drwxr-xr-x   1 root root     1838 Aug 19 13:07 etc
drwxr-xr-x   1 root root        0 Apr 15  2020 home
lrwxrwxrwx   1 root root        7 Aug  1 13:22 lib -> usr/lib
lrwxrwxrwx   1 root root        9 Aug  1 13:22 lib32 -> usr/lib32
lrwxrwxrwx   1 root root        9 Aug  1 13:22 lib64 -> usr/lib64
lrwxrwxrwx   1 root root       10 Aug  1 13:22 libx32 -> usr/libx32
drwxr-xr-x   1 root root        0 Aug  1 13:22 media
drwxr-xr-x   1 root root        0 Aug  1 13:22 mnt
drwxr-xr-x   1 root root        0 Aug  1 13:22 opt
dr-xr-xr-x 378 root root        0 Aug 19 13:07 proc
drwx------   1 root root       30 Aug 14 11:31 root
drwxr-xr-x   1 root root       90 Aug 14 11:30 run
lrwxrwxrwx   1 root root        8 Aug  1 13:22 sbin -> usr/sbin
-rw-r--r--   1 root root 17485519 Aug 14 11:29 shbr-echo.jar
-rw-r--r--   1 root root      456 Oct 13  2021 shbr-echo.py
drwxr-xr-x   1 root root        0 Aug  1 13:22 srv
dr-xr-xr-x  13 root root        0 Aug 19 13:07 sys
drwxrwxrwt   1 root root       22 Aug 14 11:30 tmp
drwxr-xr-x   1 root root      116 Aug 14 11:30 usr
drwxr-xr-x   1 root root       90 Aug  1 13:25 var
```

Видим, что в корне лежат наши два приложения **shbr-echo.jar** и **shbr-echo.py**.

Соответственно есть файл **entrypoint.sh***, который непосредственно запускает приложения.

`cat entrypoint.sh`

```bash
#!/bin/bash
set -e

if [ "$LANG" == "java" ]; then
  exec -- /usr/bin/java -jar /shbr-echo.jar
elif [ "$LANG" == "python" ]; then
  exec -- /usr/bin/python3 /shbr-echo.py
else
  echo 'Unknown language'
  exit 1;
fi
```

Выходим

`exit`

Снова запускаем на контейнер, на этот раз прямой командой.

`docker run -it -p 10000:10000 -d cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest`

```bash
defe21d09dc12869abc91372f0a29a8a99f589cc69d979b2c2cf280cfb604574
```

Проверяем, что контейнер запустился:

`docker ps`

```bash
CONTAINER ID   IMAGE                                                          COMMAND            CREATED          STATUS          PORTS                                           NAMES
defe21d09dc1   cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest   "/entrypoint.sh"   13 seconds ago   Up 12 seconds   0.0.0.0:10000->10000/tcp, :::10000->10000/tcp   exciting_payne
```

##### Запуск приложения

Вызываем приложение, проверяем, что оно работает - возвращает то, что мы ей передали (hello):

`curl http://localhost:10000/hello`

    hello%

Если запускать с флагом -v, можно увидеть более подробную информацию, например? приложение, которое вернуло нам ответ (в ранном случа python):

`curl -v http://localhost:10000/hello`

```bash
*   Trying 127.0.0.1:10000...
* Connected to localhost (127.0.0.1) port 10000 (#0)
> GET /hello HTTP/1.1
> Host: localhost:10000
> User-Agent: curl/7.84.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< X-Shbr-Lang: python
< Content-Type: text/plain; charset=utf-8
< Content-Length: 5
< Date: Fri, 19 Aug 2022 13:25:13 GMT
< Server: Python/3.8 aiohttp/3.8.1
< 
* Connection #0 to host localhost left intact
hello%    
```

### Вопросы после модуля:

Преимущество пакета - написали библиотеку и ее нужно распространять, там нет ничего, что запускается, нужно доставить файлы на целевую машину. Докер контейнер здесь плохо подходит, потому, что у нас есть две библиотеки, которые лежат в двух докер-образах - мы не можем наследоваться от двух образов, нам нужны обе. Также виртуализация не во всех отраслях может применяться из-за соображения безопасности. Есть легаси истории, где пакеты доминируют и переехать на контейнеры очень сложно.

Пакет debian - это архив с файлами, которые мы собрали с дополнительной мета-информацией и утилита, пакетный менеджер эти пакеты распаковывают, читают и выполняют инструкции, которые мы написали к этому пакету.

Файлы для пакета debian (4 шт.) пишутся вручную, затем собираются. Для rpm пакета другая схема, там один файл разделенный на секции. Т.е. нужно смотреть с каким пакетным менеджером вы работаете.

### 3. Доставка

Как доставить наше приложение на машину, на которой оно будет непосредственно выполняться.

**Пропустим самые тревиальные методы:**

- scp (копирование через ssh)
- ftp
- rsync (утилита)
- git pull

#### 3.1. Пакеты (.deb, .rpm)

Переходим в delivery-deb

`cd vs_code/02-delivery-deb` 

`ls`

```
Dockerfile  hint.sh  Makefile  Release
```

В папке заранее заготовлены короткие команды для запуска (см .файл Makefile):

```bash
docker-build:
    docker build -t cr.yandex/crpamim8dasm0u97qtpf/shbr-02-delivery-deb:latest .
docker-run:
    docker run -it cr.yandex/crpamim8dasm0u97qtpf/shbr-02-delivery-deb:latest
docker-push:
    docker push cr.yandex/crpamim8dasm0u97qtpf/shbr-02-delivery-deb:latest%  
```

`make docker-run`  # запустили контейнер

    docker run -it cr.yandex/crpamim8dasm0u97qtpf/shbr-02-delivery-deb:latest
    shbr@5280b634ec34:/usr/local/www/debs$ 

`ls` # смотрим, что внутри

    Release  focal

Здесь заготовлен некий скелет, который поможет разобраться как работает репозиторий с пакетами и что происходит, когда выполняется команда `apt get update`,`apt get install` (ubuntu) и т.д.

Вернемся назад, посмотрим файл подсказку hint.sh в папке 02-delivery-deb:

```bash
#!/bin/bash

gpg --gen-key
gpg --output key.pub --armor --export $KEYID

dpkg-scanpackages focal/ > focal/Packages
gzip --keep --force -9 focal/Packages

cat Release > focal/Release
apt-ftparchive release focal/ >> focal/Release

gpg -abs -o focal/Release.gpg focal/Release
gpg --clearsign --digest-algo SHA512 -o focal/InRelease focal/Release

echo 'deb http://localhost/debs/ focal/' > /etc/apt/sources.list.d/localhost.list

curl http://localhost/debs/key.pub | apt-key add -
```

   

#### Подписывание (bonus)

Небольшое отступление от темы. Подписывание. Существует проблема безопасности с пакетными репозиториями. Например, есть репозиторий, в нем пакет, который вам нужен. Но как убедиться, что этот пакет никто не подменил и не подложил вредоносный код. Для этого существует метод асиметричной подписи. Для этого нужно сгенерировать ключ (состоит из приватной и публичной части).  Публичную часть ключа нужно установить на целевую машину. Т.о. машина сможет проверить, что тот ключ, который поставлен в системе и тот пакет, который мы скачиваем верный.

##### Делаем ключ

Ключ делается с помощью утилиты gpg. Соответственно нужно находиться уже в запущенном контейнере:

`gpg --gen-key`

```bash
gpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
gpg: directory '/home/shbr/.gnupg' created
gpg: keybox '/home/shbr/.gnupg/pubring.kbx' created
Note: Use "gpg --full-generate-key" for a full featured key generation dialog.

GnuPG needs to construct a user ID to identify your key.

Real name:
```

Далее нужно указать имя и адрес электронной почты,  например:

```bash
Real name: yandex-shbr
Email address: vv.bo@bk.ru

You selected this USER-ID:
    "yandex-shbr <vv.bo@bk.ru>"

Change (N)ame, (E)mail, or (O)kay/(Q)uit? o
```

Далее проверяем введенные данные, соглашаемся с ними.

Далее идет запрос на создание пароля (для подтверждения подписывания), отказываемся для простоты в данном случае. В результате увидим следующее:

```bash
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
gpg: /home/shbr/.gnupg/trustdb.gpg: trustdb created
gpg: key 5A19663A024415EB marked as ultimately trusted
gpg: directory '/home/shbr/.gnupg/openpgp-revocs.d' created
gpg: revocation certificate stored as '/home/shbr/.gnupg/openpgp-revocs.d/90BF426EC880675DB0BB2E3C5A19663A024415EB.rev'
public and secret key created and signed.

pub rsa3072 2022-08-19 [SC] [expires: 2024-08-18]
 90BF426EC880675DB0BB2E3C5A19663A024415EB
uid yandex-shbr <vv.bo@bk.ru>
sub rsa3072 2022-08-19 [E] [expires: 2024-08-18]
```

##### Файл key.pub

Итого ключ создался и сохранился в некой базе данных. Нам нужно получить его публичную часть по индентификатору, для этого есть следующая команда

`gpg --output key.pub --armor --export 90BF426EC880675DB0BB2E3C5A19663A024415EB`

`cat key.pub`  # посмотрим на публичную часть ключа

    -----BEGIN PGP PUBLIC KEY BLOCK-----
    ...
    -----END PGP PUBLIC KEY BLOCK-----

Это подготовительная часть, чтобы собрать настоящий репозиторий с пакетами.

#### 3.1. Пакеты (.deb, .rpm) продолжение

`pwd`

```bash
/usr/local/www/debs$
```

`ls`

```
Release  focal  key.pub
```

Проверим наши приложения, что они есть.

`cd /shbr-echo/`

`ls`

```bash
build  python                             shbr-echo_1.0.0-1_amd64.changes
java   shbr-echo_1.0.0-1_amd64.buildinfo  shbr-echo_1.0.0-1_amd64.deb
```

На предыдущем шаге мы собрали .deb пакет и вот он здесь **shbr-echo_1.0.0-1_amd64.deb**

Вернемся обратно

`cd /usr/local/www/debs`

`ls`

    Release  focal  key.pub

Т.к. мы работаем с версией Ubuntu Focal, нужно работать в папке focal. Копируем пакет в папку focal.

`cp /shbr-echo/shbr-echo_1.0.0-1_amd64.deb focal/`

Проверяем (скопировали пакет в папку focal/)

`ls -al focal/`

```bash
total 15076
drwxr-xr-x 1 shbr shbr       54 Aug 14 15:23 .
drwxr-xr-x 1 shbr shbr       38 Aug 14 15:00 ..
-rwxr-xr-x 1 shbr shbr 15434720 Aug 14 15:23 shbr-echo_1.0.0-1_amd64.deb
```

С помощью команды dpkg-scanpackages можно пройти по дирректории и получить список пакетов в дирректории:

`dpkg-scanpackages focal/`

    Package: shbr-echo
    Version: 1.0.0-1
    Architecture: amd64
    Maintainer: Grigory Ozhegov <ozhegov@yandex-team.ru>
    Installed-Size: 17081
    Filename: focal/shbr-echo_1.0.0-1_amd64.deb
    Size: 15434720
    MD5sum: 5ea34c0c2caec2be2955a9de4ae664f2
    SHA1: 0eb6a88cb482f75ff85093440f2f03de0367c633
    SHA256: 049b73c14f572d6054a2a062497a1e3c9c3f43a6bc9c634033723bfb0640b9ce
    Section: devel
    Priority: optional
    Description: shbr echo server
    
    dpkg-scanpackages: info: Wrote 1 entries to output Packages file.

##### Файл Packages

Выведем содержимое этого файла в папку focal с информацией о пакетах всего репозитория:

`dpkg-scanpackages focal/ > focal/Packages`

    dpkg-scanpackages: info: Wrote 1 entries to output Packages file.

Проверим папку focal (там должен быть пакет и файл Packages с описанием пакета):

`shbr@5280b634ec34:/usr/local/www/debs/focal$ ls -la`

    total 15080
    drwxr-xr-x 1 shbr shbr       70 Aug 15 07:13 .
    drwxr-xr-x 1 shbr shbr       38 Aug 15 06:52 ..
    -rw-r--r-- 1 shbr shbr      416 Aug 15 07:13 Packages
    -rwxr-xr-x 1 shbr shbr 15434720 Aug 15 07:07 shbr-echo_1.0.0-1_amd64.deb

Информация о пакетах репозитория

`cat Packages`

    Package: shbr-echo
    Version: 1.0.0-1
    Architecture: amd64
    Maintainer: Grigory Ozhegov <ozhegov@yandex-team.ru>
    Installed-Size: 17081
    Filename: focal/shbr-echo_1.0.0-1_amd64.deb
    Size: 15434720
    MD5sum: 5ea34c0c2caec2be2955a9de4ae664f2
    SHA1: 0eb6a88cb482f75ff85093440f2f03de0367c633
    SHA256: 049b73c14f572d6054a2a062497a1e3c9c3f43a6bc9c634033723bfb0640b9ce
    Section: devel
    Priority: optional
    Description: shbr echo server

##### Файл Packages.gz

Обычно файл Pakages большой, его нужно сжимать:

`gzip --keep --force -9 Packages` # сжимаем

`la -al` # поверяем

```bash
total 15084
drwxr-xr-x 1 shbr shbr       92 Aug 15 07:18 .
drwxr-xr-x 1 shbr shbr       38 Aug 15 06:52 ..
-rw-r--r-- 1 shbr shbr      416 Aug 15 07:13 Packages
-rw-r--r-- 1 shbr shbr      331 Aug 15 07:13 Packages.gz                    #немного сжался
-rwxr-xr-x 1 shbr shbr 15434720 Aug 15 07:07 shbr-echo_1.0.0-1_amd64.deb
```

Сжатый файл можно просматривать вот так:

`gunzip -c Packages.gz`

##### Файл Release

Помимо списка пакетов в репозитории у нас еще есть файл с мета-информацией  о самом репозитории. Название, под каку версию операционной системы он сделан, описание, каким ключем подписаны наши пакеты.

`cat Release`

    Origin: shbr
    Label: shbr
    Codename: focal
    Architectures: amd64
    Components: contrib
    Description: shbr
    SignWith: shbr@668e171b9e60:/usr/local/www/debs$ 

Этот фалик тоже нужно переложить в Focal, копируем:

`cat Release > focal/Release`

`ls -al focal/`

    total 15088
    drwxr-xr-x 1 shbr shbr      106 Aug 15 07:27 .
    drwxr-xr-x 1 shbr shbr       38 Aug 15 06:52 ..
    -rw-r--r-- 1 shbr shbr      416 Aug 15 07:13 Packages                        # список пакетов
    -rw-r--r-- 1 shbr shbr      331 Aug 15 07:13 Packages.gz                    # сжатая версия списка пакетов
    -rw-r--r-- 1 shbr shbr      110 Aug 15 07:28 Release                        # информация о репозитории
    -rwxr-xr-x 1 shbr shbr 15434720 Aug 15 07:07 shbr-echo_1.0.0-1_amd64.deb    # пакет .deb

##### Проверка хэш-сумм

Информация для проверки хэш-сумм наших файлов (Packages, Packages.gz, Release). Это нужно для того, чтобы когда мы делали `apt get update` , скачивается файл релиз, смотрятся какие суммы у файла Packages, скачивается файл  и за счет хэш-сумм проверяется, что мы скачали именно тот файл, который нужно и не потеряли информацию из него:

`apt-ftparchive release focal/`

    Date: Mon, 15 Aug 2022 07:30:41 +0000
    MD5Sum:
     767546c2d5f7369408664b46467591fe              416 Packages
     e2e49b4c3d6e6fe165aafb6043161611              331 Packages.gz
     18691a1fb1e423401ae2b1469e14c805              110 Release
    SHA1:
     1bfd6af2c1cb462d5917a6566bc78ca858c668b9              416 Packages
     e4971db5c49430d39e6a305c03e99f2cc954b81c              331 Packages.gz
     b433089df1b961d861766f2cf63702d25da65773              110 Release
    SHA256:
     1f62f61bb6f7e196a190531769fad074ac09609e7463e61b8ae566e1bfa38f32              416 Packages
     1d31094b1944d6971b5f1e226ae53e8a85b12f5bc07ca4d15f5eb13a877d5a32              331 Packages.gz
     99557fb9712bbde5e14c91fdee1a7b06aa9df2d196ca894ab990f2b777c63461              110 Release
    SHA512:
     b1f9b43566a450f2178409bb60df8fab971c6a0584f1e017f1bf4793ba85b0082d225719c3cb2469237df9b330c0bdcb49627d1c9ae57a7de8ad9ec291b46434              416 Packages
     216ba9f992fc11f942815c34bf909c172b282d21943650c6eef5aff9da1f868e261b07b99ad7957a63af640520804e5bb8004345b0003f3211497c00c8b72825              331 Packages.gz
     9aa848ba984d519501e57abe170bff4237427d7061e6ba7af377ae1cda652269e4e740f09a1d9634f243b9427203607567bbd520e04d69bd7049520a669936fd              110 Release

##### Дополнение файла Release

Дописываем эту информацию в файл Release

`apt-ftparchive release focal/ >> focal/Release`

`cat focal/Release` # проверяем

```bash
Origin: shbr
Label: shbr
Codename: focal
Architectures: amd64
Components: contrib
Description: shbr
SignWith: Date: Mon, 15 Aug 2022 07:33:13 +0000
MD5Sum:
 767546c2d5f7369408664b46467591fe              416 Packages
 e2e49b4c3d6e6fe165aafb6043161611              331 Packages.gz
 dc0f183c2b347946c75ae66560374001              148 Release
SHA1:
 1bfd6af2c1cb462d5917a6566bc78ca858c668b9              416 Packages
 e4971db5c49430d39e6a305c03e99f2cc954b81c              331 Packages.gz
 a43d92c374dac178d7c93c96ac2f82f5e8407f2b              148 Release
SHA256:
 1f62f61bb6f7e196a190531769fad074ac09609e7463e61b8ae566e1bfa38f32              416 Packages
 1d31094b1944d6971b5f1e226ae53e8a85b12f5bc07ca4d15f5eb13a877d5a32              331 Packages.gz
 79d485a501f4bb390f7d84185e27e5448ca27eb503577522f3c9d779346ef338              148 Release
SHA512:
 b1f9b43566a450f2178409bb60df8fab971c6a0584f1e017f1bf4793ba85b0082d225719c3cb2469237df9b330c0bdcb49627d1c9ae57a7de8ad9ec291b46434              416 Packages
 216ba9f992fc11f942815c34bf909c172b282d21943650c6eef5aff9da1f868e261b07b99ad7957a63af640520804e5bb8004345b0003f3211497c00c8b72825              331 Packages.gz
 073ce52f6ad162a75625d4093485c2b7957488fe1fce5cb56b1443c60bfd93802bcab57330954a211f817c99c137341f5fac4a3d03b23832e439027bfcf29545              148 Release
```

##### Файл Release.gpg (подпись)

Файл нужно подписать (подписывая файл мы гарантируем, что его никто не подменил). Подписываем

`gpg -abs -o focal/Release.gpg focal/Release`

Проверяем (файл Release.gpg - это подпись):

`cat focal/Release.gpg`

```bash
-----BEGIN PGP SIGNATURE-----

iQGzBAABCgAdFiEEp2/rjzxoTauULjGxycJ4dJM/sS4FAmL59yYACgkQycJ4dJM/
sS6F2Qv/dwGWp1ZDvClqox/xC5igf1DQCttnp3+mhMkulQOzdIcB98iN+JA04Hkw
S1Goy/7RLxd9+qQy9c5FvUXyHSvTfETOtI0SQ/hg7qdDBNipwRMKPWq3gPBRLeuP
9gFnW9+BrdikRKPsSbSKAMUtXPoEBBLWw5QwzPe159+Nv8CR8jxxDThuRRdxNmWV
RJa6+HzBQWlnGypnymRuC4XS78qibynzANduuKR1Q0OEJqT3gjsvYQ4+bK/bKAcm
Zejmw9bjZwtHVXcwjXiv6hxV//J6mjSV8Fsyw721QWfPTomMhOhcZ1BKnEERmh/k
6e+W2vNO6t8cFcKX8mDsWKSVY14KSm5EH5JOSdF/sQEGiRkWyTJ0idaR1FcHKIke
nWr8cpODtztkMFvC3VojeijYoxAgkgn1W6kx1uYTPlKlBvYg9VPvAbmZw35Z04Z6
pzQLxwmYKgYsSV2rgwzgCFKC74AXSiPO5VR7tGluUpib/TMhK6U85EBQFxlz7z02
wEs6xAgo
=Lyzb
-----END PGP SIGNATURE-----
```

Асиметричное шифрование работает так - мы подписываем приватным ключем, публичный ключ вешаем на заборе и также у каждого файла есть подпись
и дальше человек-пользователь, который хочет проверить тот ли это файл у которого есть приватная часть ключа - он спомощью публичного ключа
на заборе и этой подписи может провалидировать, что этот файл от изначального отправителя. 

Проверяем, что лежит в репозитории

`ls -al focal/`

```bash
total 15092
drwxr-xr-x 1 shbr shbr      128 Aug 15 07:35 .
drwxr-xr-x 1 shbr shbr       38 Aug 15 06:52 ..
-rw-r--r-- 1 shbr shbr      416 Aug 15 07:13 Packages
-rw-r--r-- 1 shbr shbr      331 Aug 15 07:13 Packages.gz
-rw-r--r-- 1 shbr shbr     1314 Aug 15 07:33 Release
-rw-r--r-- 1 shbr shbr      659 Aug 15 07:35 Release.gpg                    # добавилась подпись для файла релиз
-rwxr-xr-x 1 shbr shbr 15434720 Aug 15 07:07 shbr-echo_1.0.0-1_amd64.deb
```

##### Файл InRelease

Для новых версий Ubuntu есть еще файл InRelease ()

`cd ../`

`gpg --clearsign --digest-algo SHA512 -o focal/InRelease focal/Release`

`cat focal/InRelease` # ЭТО РЕЛИЗ ФАЙЛ СО ВСТРОЕННОЙ ПОДПИСЬЮ)

```bash
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Origin: shbr
Label: shbr
Codename: focal
Architectures: amd64
Components: contrib
Description: shbr
SignWith: Date: Mon, 15 Aug 2022 07:33:13 +0000
MD5Sum:
 767546c2d5f7369408664b46467591fe              416 Packages
 e2e49b4c3d6e6fe165aafb6043161611              331 Packages.gz
 dc0f183c2b347946c75ae66560374001              148 Release
SHA1:
 1bfd6af2c1cb462d5917a6566bc78ca858c668b9              416 Packages
 e4971db5c49430d39e6a305c03e99f2cc954b81c              331 Packages.gz
 a43d92c374dac178d7c93c96ac2f82f5e8407f2b              148 Release
SHA256:
 1f62f61bb6f7e196a190531769fad074ac09609e7463e61b8ae566e1bfa38f32              416 Packages
 1d31094b1944d6971b5f1e226ae53e8a85b12f5bc07ca4d15f5eb13a877d5a32              331 Packages.gz
 79d485a501f4bb390f7d84185e27e5448ca27eb503577522f3c9d779346ef338              148 Release
SHA512:
 b1f9b43566a450f2178409bb60df8fab971c6a0584f1e017f1bf4793ba85b0082d225719c3cb2469237df9b330c0bdcb49627d1c9ae57a7de8ad9ec291b46434              416 Packages
 216ba9f992fc11f942815c34bf909c172b282d21943650c6eef5aff9da1f868e261b07b99ad7957a63af640520804e5bb8004345b0003f3211497c00c8b72825              331 Packages.gz
 073ce52f6ad162a75625d4093485c2b7957488fe1fce5cb56b1443c60bfd93802bcab57330954a211f817c99c137341f5fac4a3d03b23832e439027bfcf29545              148 Release
-----BEGIN PGP SIGNATURE-----

iQGzBAEBCgAdFiEEp2/rjzxoTauULjGxycJ4dJM/sS4FAmL5+ngACgkQycJ4dJM/
sS7XJwv9HezzfOmOZlcstgA09l1UgyD0welnZgHNIWaljTp3NTzCfmb8CU4Q9Ipd
w5D1SF0Gj2d7aDLJyCYUg4PPizmqgrSNP98OszhXNGMcTVO1auUfGXCvxpfxNVzh
Tf942eKMJymEvWlh0hPnACe8EoU7FkL/+NYERuaJz0DIlw29tt18QL7r2HJBJVx/
8nO++KRO1IX3JLt8x1G2r/r/Q2xbFnVJxdylTyp+6L0fQOmPEijl2c7tXvcvxOiB
gIxGK4vc6hMoems+4LRZI+kH3507wX/q5GaujB4ygOyS1o0lJtpNWud+pL3yLFLI
9RwXqMLtc8ii5a4Rl0wx1lZHchDpYqalt28yTkbCWCiIuyRR8oOavI5L4Nnbzlx1
tnmcIKVx05bBzwFZzL7Y+WTxFgymJsif0ux6Zxt7RLZLyz+haPk6PQSBVoxmY6no
E2zmDhuz8nQAQYQzzKxexbxYRtb4U2TL7izDaMvxbF4wi6rgXP8O/22P/E8KzQb0
0kjLs2u1
=XPAr
-----END PGP SIGNATURE-----
```

Смотрим, что получилось. 

ИТОГО СФОРМИРОВАЛИ .DEB РЕПОЗИТОРИЙ

`ls -al focal/`      

```bash
total 15096
drwxr-xr-x 1 shbr shbr      146 Aug 15 07:49 .
drwxr-xr-x 1 shbr shbr       38 Aug 15 06:52 ..
-rw-r--r-- 1 shbr shbr     2022 Aug 15 07:49 InRelease                            # добавился файл со встроенной подписью (раньше было два файла - релиз и подпись)
-rw-r--r-- 1 shbr shbr      416 Aug 15 07:13 Packages
-rw-r--r-- 1 shbr shbr      331 Aug 15 07:13 Packages.gz
-rw-r--r-- 1 shbr shbr     1314 Aug 15 07:33 Release                            # релиз (старая схема Ubuntu с двумя файлами)
-rw-r--r-- 1 shbr shbr      659 Aug 15 07:35 Release.gpg                        # подпись релиза (старая схема Ubuntu с двумя файлами)
-rwxr-xr-x 1 shbr shbr 15434720 Aug 15 07:07 shbr-echo_1.0.0-1_amd64.deb
```

Когда выполняем `apt get` ubuntu сначала пробуеn скачать один файл InRelease, если не получается - переходим к старой схеме с двумя файлами. Итого мы сформировали .deb репозиторий. 

##### Установка deb-пакета

Попробуем установить этот пакет, используя apt get. Убеждаемся, что пакет этот в user/bin еще не установлен.

`ls /user/bin/shbr*`

    ls: cannot access '/user/bin/shbr*': No such file or directory

Чтобы установить пакет нужно указать системе откуда его нужно взять. Для этого выполняем команду:

`echo 'deb http://localhost/debs/ focal/' > /etc/apt/sources.list.d/localhost.list`

...и получаем ошибку

    bash: /etc/apt/sources.list.d/localhost.list: Permission denied

Это частый кейс. Даже если выполняем от root все равно вылезает таже ошибка:

`sudo echo 'deb http://localhost/debs/ focal/' > /etc/apt/sources.list.d/localhost.list`

    bash: /etc/apt/sources.list.d/localhost.list: Permission denied

Когда добавляем sudo в начало, от root выполняется только первая команда, вывода на экран, а вывод в файл выполняется от текущего пользователя. Лечится это командой **tee**. Команда **tee*** это так называемый трехсторонний пайпинг.

`echo 'deb http://localhost/debs/ focal/' | sudo tee /etc/apt/sources.list.d/localhost.list`

    deb http://localhost/debs/ focal/

Соответственно, то, что выполнило echo мы получили на экране, и дальше от root записали наш файл. 

Итого добавили наш репозиторий, пробуем установить.

Пробуем установить, делается это от root:

`sudo apt-get update`

    Err:1 http://localhost/debs focal/ InRelease
      Could not connect to localhost:80 (127.0.0.1). - connect (111: Connection refused)
    ...
    ...
    W: Failed to fetch http://localhost/debs/focal/InRelease  Could not connect to localhost:80 (127.0.0.1). - connect (111: Connection refused)

Установить наш InRelease не получилось. Был создан запрос на localhost:80, и получен ответ - нет соединения с "удаленным" сервером.

Запускаем сервер для раздачи наших файлов:

`python3 -m http.server 80`

    Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...

Открываем новый терминал, переходим в то же окружение. Смотрим список запущенных контейнеров докер:

`docker ps`

    CONTAINER ID   IMAGE                                                        COMMAND       CREATED       STATUS       PORTS     NAMES
    5280b634ec34   cr.yandex/crpamim8dasm0u97qtpf/shbr-02-delivery-deb:latest   "/bin/bash"   2 hours ago   Up 2 hours             amazing_liskov

Заходим в этот контейнер

`docker exec -it 5280b634ec34 bash`

Видим, что у нас запущен сервер на 80 порту:

`ps aux`

    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    shbr           1  0.0  0.0   4248  3600 pts/0    Ss   06:36   0:00 /bin/bash
    shbr          13  0.0  0.0  78236  3292 ?        Ss   06:50   0:01 gpg-agent --homedir /home/shbr/.gnupg
    shbr         405  0.0  0.0  12972  8948 pts/0    T    08:22   0:00 python3
    shbr         406  0.0  0.1  21412 16176 pts/0    S+   08:23   0:00 python3 -m http.server 80                    # вот он наш запущенный сервер
    shbr         407  0.0  0.0   4252  3488 pts/1    Ss   08:25   0:00 bash
    shbr         414  0.0  0.0   5900  3012 pts/1    R+   08:25   0:00 ps aux

Выполняем обновление через терминал 2

`sudo apt-get update`

    Get:1 http://localhost/debs focal/ InRelease [2022 B]
    Err:1 http://localhost/debs focal/ InRelease                                                           
      The following signatures couldn't be verified because the public key is not available: NO_PUBKEY C9C27874933FB12E
    Hit:2 http://security.ubuntu.com/ubuntu focal-security InRelease                                       
    Hit:3 http://ppa.launchpad.net/linuxuprising/java/ubuntu focal InRelease                        
    Hit:4 http://archive.ubuntu.com/ubuntu focal InRelease                    
    Hit:5 http://archive.ubuntu.com/ubuntu focal-updates InRelease
    Hit:6 http://archive.ubuntu.com/ubuntu focal-backports InRelease
    Reading package lists... Done
    W: GPG error: http://localhost/debs focal/ InRelease: The following signatures couldn't be verified because the public key is not available: NO_PUBKEY C9C27874933FB12E
    E: The repository 'http://localhost/debs focal/ InRelease' is not signed.
    N: Updating from such a repository can't be done securely, and is therefore disabled by default.
    N: See apt-secure(8) manpage for repository creation and user configuration details.

В терминале 1 видим, что команда `sudo apt-get update` сформировала запрос:

    127.0.0.1 - - [15/Aug/2022 08:27:44] "GET /debs/focal/InRelease HTTP/1.1" 200 -

Файл InRelease успешно скачался. НО ПОДПИСЬ ПРОВЕРИТЬ НЕ ПОЛУЧИЛОСЬ (signatures couldn't be verified), т.к. мы просто видим чью-то подпись, но верифицировать ее не с чем. Чтобы это починить поставим в систему публичный ключ.

Установим curl:

`sudo apt-get install curl`

Смотрим файл InRelease:

`curl http://localhost/debs/focal/InRelease`

    -----BEGIN PGP SIGNED MESSAGE-----
    Hash: SHA512
    
    Origin: shbr
    Label: shbr
    Codename: focal
    Architectures: amd64
    Components: contrib
    Description: shbr
    SignWith: Date: Mon, 15 Aug 2022 07:33:13 +0000
    MD5Sum:
     767546c2d5f7369408664b46467591fe              416 Packages
     e2e49b4c3d6e6fe165aafb6043161611              331 Packages.gz
     dc0f183c2b347946c75ae66560374001              148 Release
    SHA1:
     1bfd6af2c1cb462d5917a6566bc78ca858c668b9              416 Packages
     e4971db5c49430d39e6a305c03e99f2cc954b81c              331 Packages.gz
     a43d92c374dac178d7c93c96ac2f82f5e8407f2b              148 Release
    SHA256:
     1f62f61bb6f7e196a190531769fad074ac09609e7463e61b8ae566e1bfa38f32              416 Packages
     1d31094b1944d6971b5f1e226ae53e8a85b12f5bc07ca4d15f5eb13a877d5a32              331 Packages.gz
     79d485a501f4bb390f7d84185e27e5448ca27eb503577522f3c9d779346ef338              148 Release
    SHA512:
     b1f9b43566a450f2178409bb60df8fab971c6a0584f1e017f1bf4793ba85b0082d225719c3cb2469237df9b330c0bdcb49627d1c9ae57a7de8ad9ec291b46434              416 Packages
     216ba9f992fc11f942815c34bf909c172b282d21943650c6eef5aff9da1f868e261b07b99ad7957a63af640520804e5bb8004345b0003f3211497c00c8b72825              331 Packages.gz
     073ce52f6ad162a75625d4093485c2b7957488fe1fce5cb56b1443c60bfd93802bcab57330954a211f817c99c137341f5fac4a3d03b23832e439027bfcf29545              148 Release
    -----BEGIN PGP SIGNATURE-----
    
    iQGzBAEBCgAdFiEEp2/rjzxoTauULjGxycJ4dJM/sS4FAmL5+ngACgkQycJ4dJM/
    sS7XJwv9HezzfOmOZlcstgA09l1UgyD0welnZgHNIWaljTp3NTzCfmb8CU4Q9Ipd
    w5D1SF0Gj2d7aDLJyCYUg4PPizmqgrSNP98OszhXNGMcTVO1auUfGXCvxpfxNVzh
    Tf942eKMJymEvWlh0hPnACe8EoU7FkL/+NYERuaJz0DIlw29tt18QL7r2HJBJVx/
    8nO++KRO1IX3JLt8x1G2r/r/Q2xbFnVJxdylTyp+6L0fQOmPEijl2c7tXvcvxOiB
    gIxGK4vc6hMoems+4LRZI+kH3507wX/q5GaujB4ygOyS1o0lJtpNWud+pL3yLFLI
    9RwXqMLtc8ii5a4Rl0wx1lZHchDpYqalt28yTkbCWCiIuyRR8oOavI5L4Nnbzlx1
    tnmcIKVx05bBzwFZzL7Y+WTxFgymJsif0ux6Zxt7RLZLyz+haPk6PQSBVoxmY6no
    E2zmDhuz8nQAQYQzzKxexbxYRtb4U2TL7izDaMvxbF4wi6rgXP8O/22P/E8KzQb0
    0kjLs2u1
    =XPAr
    -----END PGP SIGNATURE-----

В терминале 1 видим этот повторный запрос 

    127.0.0.1 - - [15/Aug/2022 08:27:44] "GET /debs/focal/InRelease HTTP/1.1" 200 -
    127.0.0.1 - - [15/Aug/2022 08:32:34] "GET /debs/focal/InRelease HTTP/1.1" 200 -

УСТАНОВИМ В СИСТЕМУ ПУБЛИЧНЫЙ КЛЮЧ. 

Скачаем публичный ключ (команда sudo apt-key add -)

`curl http://localhost/debs/key.pub | sudo apt-key add -`

      % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                     Dload  Upload   Total   Spent    Left  Speed
    100  2444  100  2444    0     0  2386k      0 --:--:-- --:--:-- --:--:-- 2386k
    OK

В терминале 1. тоже видим, что запрос на копирование key.pub успешно выполнен:

    127.0.0.1 - - [15/Aug/2022 08:27:44] "GET /debs/focal/InRelease HTTP/1.1" 200 -
    127.0.0.1 - - [15/Aug/2022 08:32:34] "GET /debs/focal/InRelease HTTP/1.1" 200 -
    127.0.0.1 - - [15/Aug/2022 08:39:38] "GET /debs/key.pub HTTP/1.1" 200 -

Теперь пробуем обновиться уже с ключем:

`sudo apt-get update`

    Get:1 http://localhost/debs focal/ InRelease [2022 B]
    Hit:2 http://ppa.launchpad.net/linuxuprising/java/ubuntu focal InRelease                               
    Get:3 http://localhost/debs focal/ Packages [331 B]                                                    
    Hit:4 http://archive.ubuntu.com/ubuntu focal InRelease                                                 
    Hit:5 http://archive.ubuntu.com/ubuntu focal-updates InRelease             
    Hit:6 http://security.ubuntu.com/ubuntu focal-security InRelease
    Hit:7 http://archive.ubuntu.com/ubuntu focal-backports InRelease
    Fetched 2353 B in 1s (4168 B/s)
    Reading package lists... Done
    W: Invalid 'Date' entry in Release file /var/lib/apt/lists/partial/localhost_debs_focal_InRelease

Уже почти хорошо, но ругается на дату (но это не критично).

В логах http-сервера (терминал 1) видим, что InRelease и Packages.gz успешно скачались:

    127.0.0.1 - - [15/Aug/2022 08:27:44] "GET /debs/focal/InRelease HTTP/1.1" 200 -
    127.0.0.1 - - [15/Aug/2022 08:32:34] "GET /debs/focal/InRelease HTTP/1.1" 200 -
    127.0.0.1 - - [15/Aug/2022 08:39:38] "GET /debs/key.pub HTTP/1.1" 200 -
    127.0.0.1 - - [15/Aug/2022 08:41:39] "GET /debs/focal/InRelease HTTP/1.1" 200 -
    127.0.0.1 - - [15/Aug/2022 08:41:39] "GET /debs/focal/Packages.gz HTTP/1.1" 200 -

Можно устанавливать:

`sudo apt-get install shbr-echo`

    Reading package lists... Done
    Building dependency tree       
    Reading state information... Done
    The following NEW packages will be installed:
      shbr-echo
    0 upgraded, 1 newly installed, 0 to remove and 1 not upgraded.
    Need to get 15.4 MB of archives.
    After this operation, 17.5 MB of additional disk space will be used.
    Get:1 http://localhost/debs focal/ shbr-echo 1.0.0-1 [15.4 MB]
    Fetched 15.4 MB in 0s (158 MB/s)   
    debconf: unable to initialize frontend: Dialog
    debconf: (No usable dialog-like program is installed, so the dialog based frontend cannot be used. at /usr/share/perl5/Debconf/FrontEnd/Dialog.pm line 76, <> line 1.)
    debconf: falling back to frontend: Readline
    Selecting previously unselected package shbr-echo.
    (Reading database ... 24930 files and directories currently installed.)
    Preparing to unpack .../shbr-echo_1.0.0-1_amd64.deb ...
    Unpacking shbr-echo (1.0.0-1) ...
    Setting up shbr-echo (1.0.0-1) ...

В терминале 1 видим, что наш пакет успешно загружен:

    127.0.0.1 - - [15/Aug/2022 08:45:10] "GET /debs/focal/shbr-echo_1.0.0-1_amd64.deb HTTP/1.1" 200 -

ИТОГО ПАКЕТ УСТАНОВИЛСЯ, ФАЙЛЫ ПРИЕХАЛИ!!!

Репозиторий с .deb пакетами это http-сервер, который раздает пакеты, которые мы собрали. Также он отдает мета-файлы о репозитории. Соответсвенно, оперируя этими сущьностями можно отдебажить, что происходит.

#### 3.2. Docker-контейнер

Будем запускать  свой маленький докер-репозиторий. В терминах докера он называется registry. Первое с чем сталкивается пользлватель docker - это docker-hub, т.к. docker его использует по умолчанию. В данном случае сделаем свой маленький registry и его раскрутим.

Теперь делаем через docker в папке 02-delivery-docker

`cd vs_code/02-delivery-docker`

`ls`

```bash
Dockerfile  Dockerfile.registry  Makefile
```

`cat Dockerfile`

В данном докер-файле наследуется докер-контейнер, который мы собрали на первом этапе.

```bash
FROM cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest
```

В файле Dockerfile.registry добавлено несколько пакетов, чтобы нам было веселее. А отнаследовались мы от образа registry:

`cat Dockerfile.registry`

```bash
FROM registry:2

RUN apk add tcpdump ngrep bash% 
```

Смотрим на Makefile:

```bash
docker-build:
 docker build -t localhost:5001/shbr-02-delivery-docker:latest .

docker-push-local:
 docker push localhost:5001/shbr-02-delivery-docker:latest

#registry
docker-build-registry:
 docker build -t registry:local -f Dockerfile.registry .

docker-run-registry:
 docker run -v $$(pwd)/.registry:/var/lib/registry -p 5001:5001 --name registry registry:local

docker-shell-registry:
 docker exec -it registry /bin/bash
```

##### docker-registry

Docer-registry - это приложение, написанное на языке Go, оно собрано в пакет registry. Запускаем наш registry через Терминал 1 (ПОЛУЧИЛОСЬ ТОЛЬКО КОГДА ЗАПУСТИЛ НА 5000):

`docker build -t localhost:5001/shbr-02-delivery-docker:latest .`

`docker run -p 5001:5000 --name registry registry:local` 

5001 - это порт на localhost, а запросы,которые мы на него отправляем попадут в докер контейнер на порт 5001. Итого приложение запущено, откроем второй терминал и будем проверять, когда мы с  ним что-то делаем.

В терминале 2. выполняем:

`docker images`  # проверяем, что приложение запустилось

##### Скачивание приложения

Добавляем приложение в локальный репозиторий:

`docker push localhost:5001/shbr-02-delivery-docker:latest`

```bash
The push refers to repository [localhost:5001/shbr-02-delivery-docker]
4cd4b9c5dace: Pushed 
4fd6a6f21d7d: Pushed 
e6376d4ce961: Pushed 
7aa5fc97459a: Pushed 
438ee021538c: Pushed 
ed9db35d25db: Pushed 
a06f3c34b880: Pushed 
f236ee947fcc: Pushed 
765eec8b6ba4: Pushed 
41934ee2689d: Pushed 
6e93bbbc2931: Pushed 
d2610e750488: Pushed 
09f97a7c59b1: Pushed 
c3f11d77a5de: Pushed 
latest: digest: sha256:fbe2a1bfc330d9c49e1cef3a2db2cc3fe09c866800932e950c6485e8f92c2627 size: 3255
```

В логах нашего registry видим, что скачивание завершено.

Зайдем в контейнер registry, в терминале 2.:

`docker ps` 

Видим, что имя контейнера registry

```
CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS         PORTS                                       NAMES
0556b6520e69   registry:local   "/entrypoint.sh /etc…"   3 minutes ago   Up 3 minutes   0.0.0.0:5001->5000/tcp, :::5001->5000/tcp   registry   Up 10 minutes   0.0.0.0:5001->5000/tcp, :::5001->5000/tcp   registry
```

Переходим в запущенный контейнер registry:

`docker exec -it 0556b6520e69 bash`

Перемещаемся в папку repositories, проверяем наши файлы:

`cd /var/lib/registry/docker/registry/v2/repositories`

`ls`

    shbr-02-delivery-docker

Переходим внутрь контейнера:

`cd shbr-02-delivery-docker/`

`ls`

Здесь непосредственно те файлы, которые мы залили:

    _layers     _manifests  _uploads

Итого. У нас есть некое API, с помощью docker push отправляем в него http-запрос и заливаются слои нашего контейнера, раскладываются на диск. По http-ответам можно также дебажить. Еще есть blobs - это содержимое нашего контейнера (в них лежат бинарные данные).

##### ngrep (bonus)

Утилита ngrep, которая позволяет смотреть трафик. Т.е. можно смотреть запросы с их заголовками.

`ngrep -W byline port 5000`

```bash
interface: eth0 (172.17.0.0/255.255.0.0)
filter: ( port 5000 ) and ((ip || ip6) || (vlan && (ip || ip6)))
```

В терминале 3. 

`docker push localhost:5001/shbr-02-delivery-docker:latest`

`docker exec -it 0556b6520e69 bash`

Тогда в Терминале 2. (где запустили ngrep -W byline port 5000): 

```bash
T 172.17.0.1:43302 -> 172.17.0.2:5000 [AP] #4
............C^.....Q.........d.P=^.X.<.Rm.. (F.o.x.`......Xk.u.C..v.1...aJY....+./.,.0.....
.....................localhost..........
.
........................................................+........3.&.$... z..0.
..'pr..y...=.4.VD.?..gr.,.
##
T 172.17.0.2:5000 -> 172.17.0.1:43302 [AP] #6
HTTP/1.1 400 Bad Request.
Content-Type: text/plain; charset=utf-8.
Connection: close.
.
400 Bad Request
########
T 172.17.0.1:43310 -> 172.17.0.2:5000 [AP] #14
GET /v2/ HTTP/1.1.
Host: localhost:5001.
User-Agent: docker/20.10.17 go/go1.18.3 git-commit/a89b84221c kernel/5.15.60-1-MANJARO os/linux arch/amd64 UpstreamClient(Docker-Client/20.10.17 \(linux\)).
Accept-Encoding: gzip.
Connection: close.
.

T 172.17.0.2:5000 -> 172.17.0.1:43310 [AP] #16
HTTP/1.1 200 OK.
Content-Length: 2.
Content-Type: application/json; charset=utf-8.
Docker-Distribution-Api-Version: registry/2.0.
X-Content-Type-Options: nosniff.
Date: Fri, 19 Aug 2022 15:43:35 GMT.
Connection: close.

...
...

         "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
         "size": 241,
         "digest": "sha256:438e1f24f19a8e97b01e0d46d02bbb2a6597f8bd187334f8b7e30876fe5badd2"
      }
   ]
}
##
T 172.17.0.2:5000 -> 172.17.0.1:43466 [AP] #176
HTTP/1.1 201 Created.
Docker-Content-Digest: sha256:fbe2a1bfc330d9c49e1cef3a2db2cc3fe09c866800932e950c6485e8f92c2627.
Docker-Distribution-Api-Version: registry/2.0.
Location: http://localhost:5001/v2/shbr-02-delivery-docker/manifests/sha256:fbe2a1bfc330d9c49e1cef3a2db2cc3fe09c866800932e950c6485e8f92c2627.
X-Content-Type-Options: nosniff.
Date: Fri, 19 Aug 2022 15:43:35 GMT.
Content-Length: 0.
Connection: close.
```

Http передает очень много данных по которым можно анализировать, что происходит.

### Вопросы после модуля:

MultiStateBuilding - google-поиск, на сайте Docker отдельный раздел, технология позволяет запускать несколько контейнеров параллельно.

Докер запускается в  контейнерной виртуализации и по сути внутри полноценный линукс, в котором можно выполнять команды линукс. 

VirtualBox - аппаратная виртуализация программных команд в процессоре, аппартаные команду второй операционной системы будут выполняться непосредственно на том же процессоре, прямо асемблерные команды будут попадать в процессор и выполняться.

В докере подругому - это контейнерная виртуализация, по сути это запуск линукса внутри линукса. У изначального процесса в линукс PID 1, далее он запускает все остальные процессы. Внутри этого процесса init с PID 1  можно запустить еще один init-процесс.  Соответственно внутри одного линукса будут другие линуксы и это будет единое дерево процессов. Существует много вариантов изолировать процессы друг от друга, но при этом они выполняются в едином пространстве. Чаще всего для различных product систем используется контейнерная виртуализация, т.к. она дает сильно меньший over-head. VirtualBox и проч. потребляют гораздо больше накладных ресурсов на работу самой виртуализации.

Локальный репозиторий докера и что такое registry. Это приложение, которое принимает http-запрос и складывает на диск ваши docker-образы и дальше в одно какое-то место. На локальной машине собрали контейнер, запушили в registry, а дальше все production-машины с этого registry так же скачивают как пакеты по http докер-контейнера.

### 4. Запуск

#### NO NOHUP

Как делать нельзя! Первый пример - это NOHUP.

Весь пример снова упакован в докер-контейнер. Переходим в папку, запускаем контейнер, проваливаемся в shell:

`cd 03-run-NO_NOHUP`

`ls`

```
Dockerfile  Makefile
```

`cat Makefile`

```bash
docker-build:
    docker build -t cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-no_nohup:latest .

docker-run:
    docker run -d -it --name shbr-03-run-no_nohup cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-no_nohup:latest

docker-shell:
    docker exec -it shbr-03-run-no_nohup /bin/bash

docker-kill:
    docker kill shbr-03-run-no_nohup && docker rm shbr-03-run-no_nohup

docker-push:
    docker push cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-no_nohup:latest
```

`make docker-run`

`make docker-shell`

`ls`

```bash
bin   dev            etc   lib    lib64   media  opt   root  sbin           shbr-echo.py  sys  usr
boot  entrypoint.sh  home  lib32  libx32  mnt    proc  run   shbr-echo.jar  srv           tmp  var
```

В папке видим приложение (**shbr-echo.py** и **shbr-echo.jar**), хотим его запустить.

`python3 shbr-echo.py`

    ======== Running on http://0.0.0.0:10000 ========
    (Press CTRL+C to quit)

Если выйти из терминала, закрыть консоль - наше приложение отвалится. Мы запустили bash, а наше приложение дочернее к bash, соответсвенно если выйдем из консоли - приложение остановится. Это можно обойти через специальную утилиту nohup.

`nohup python3 shbr-echo.py &`

```bash
[1] 18
root@7cb5d7e5c640:/# nohup: ignoring input and appending output to 'nohup.out'
```

Видим, что информация по работе приложенияя собирается в файл nohub.out, но с ним тяжело работать. Пока приложение работает - файл бесконечно растет, поэтому его нужно обрезать и сжимать в идеале.

`ps aux` # смотрим процессы

```bash
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0   2552   516 pts/0    Ss+  16:36   0:00 /bin/tail -f 
root           7  0.0  0.0   4248  3616 pts/1    Ss   16:37   0:00 /bin/bash
root          18  0.2  0.1  41116 26048 pts/1    S    16:44   0:00 python3 shbr-
root          20  0.0  0.0   5900  2884 pts/1    R+   16:45   0:00 ps aux
```

Видим приложение python3 shbr-echo.py, оно не отвалилось, и мы можем к нему обращаться. Но при этом оно вне поля нашего зрения.

`curl -v http://localhost:10000`

```bash
*   Trying 127.0.0.1:10000...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 10000 (#0)
> GET / HTTP/1.1
> Host: localhost:10000
> User-Agent: curl/7.68.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< X-Shbr-Lang: python
< Content-Type: text/plain; charset=utf-8
< Content-Length: 0
< Date: Fri, 19 Aug 2022 16:49:28 GMT
< Server: Python/3.8 aiohttp/3.8.1
< 
* Connection #0 to host localhost left intact
```

Что произойдет, если, например, закончится память в приложении.

`kill -9 18` # отключим приложение с PID 18

`ps aux`

```bash
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0   2552   516 pts/0    Ss+  16:36   0:00 /bin/tail -f /dev/null
root           7  0.0  0.0   4248  3616 pts/1    Ss   16:37   0:00 /bin/bash
root          26  0.0  0.0   5900  2904 pts/1    R+   16:53   0:00 ps aux
[1]+  Killed                  nohup python3 shbr-echo.py
```

Наше приложение упало, за ним никто не следит. Оно не перезапустится.

 Но в prod так делать категорически нельзя, т.к. при перезагрузке его нельзя запустить,  потеряются ключи, которые передавались при его запуске, потреяются все переменные окружения в котором это приложение запущено.

#### NO SCREEN/TMUX

Screen прекрасная вещь, но не для deploy. 

`cat Makefile`

```bash
docker-build:
    docker build -t cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-no_screen:latest .

docker-run:
    docker run -it -d --name shbr-03-run-no_screen cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-no_screen:latest

docker-shell:
    docker exec -it shbr-03-run-no_screen /bin/bash

docker-push:
    docker push cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-no_screen:latest
```

Заходим в контейнер, проваливаемся в shell:

`make docker-run`

`make docker-shell`

`ls`

```bash
bin   entrypoint.sh  lib    libx32  opt   run            shbr-echo.py  tmp
boot  etc            lib32  media   proc  sbin           srv           usr
dev   home           lib64  mnt     root  shbr-echo.jar  sys           var
```

Запустим screen:

`screen`

Screen, как и TMUX так называемые мультиплексоры терминала.

`ctrl`+`a`+`?` # грячие клавиши

`screen -list` # список запущенных сессий

Короткий обзор по хоткеям здесь ([Команда screen Linux - Losst](https://losst.ru/komanda-screen-linux)).

Запускаем приложение:

`python3 shbr-echo.py`

Screen нам также помогает отключиться от терминала, выглядит это так:

<img src="file:///home/vibo/Pictures/GlobalMarkText/2022-08-19-20-30-03-image.png" title="" alt="" data-align="center">

Здесь SCREEN (PID 45ol), терминал (PID 46) и наше приложение (PID 54). Отключившись от терминала приложение продолжает работать. Здесь те же проблемы, что и в NOHUP.  Не видим стандартный вывод процксса, если кто-то запустил программу из под своего имени, нам будет тяжело работрабться кто его запустил.

#### Supervisor

Supervisor - это некий процесс, который запускается, у него есть config. И дальше он от своего имени запускает приложения. И следит за тем, чтобы они работали.

`cd 03-run-supervisor` # переходим в папку с контейнером
`cat Makefile`

```bash
docker-build:
    docker build -t cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-supervisor:latest .

docker-run:
    docker run -it -d --name shbr-03-run-supervisor cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-supervisor:latest

docker-push:
    docker push cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-supervisor:latest

docker-shell:
    docker exec -it shbr-03-run-supervisor /bin/bash
```

`make docker-run`
`make docker-shell`
`ls`

```bash
bin   entrypoint.sh  lib    libx32  opt   run            shbr-echo.py  tmp
boot  etc            lib32  media   proc  sbin           srv           usr
dev   home           lib64  mnt     root  shbr-echo.jar  sys           var
```

`cd /etc/supervisor/` # переходим в папку surevisor

`ls`

    conf.d  supervisord.conf

`cd conf.d/`

`ls`

    shbr.conf

`ps aux`

```bash
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.1  28432 23356 pts/0    Ss+  18:41   0:00 /usr/bin/pyth
root           8  2.9  1.1 7917352 184616 pts/0  Sl   18:41   0:09 /usr/bin/java
root           9  0.0  0.1  41112 26212 pts/0    S    18:41   0:00 /usr/bin/pyth
root          46  0.0  0.0   4248  3540 pts/1    Ss   18:42   0:00 /bin/bash
root          56  0.0  0.0   5900  2888 pts/1    R+   18:47   0:00 ps aux
```

Рассмотрим файл config

`cat shbr.conf`

```bash
[program:shbr-echo-java] # имя программы
command=/usr/bin/java -jar /shbr-echo.jar # запускать ее следующим образом
autostart=true
autorestart=true # в случае ее подения мы ее перезапускаем
stopasgroup=true
killasgroup=true
stdout_logfile=/var/log/supervisor/java.stdout.log # если что-то выдает в стандартный вывод - пишем в этот файл
stderr_logfile=/var/log/supervisor/java.stderr.log

[program:shbr-echo-python] # имя программы
environment=PORT=10001
command=/usr/bin/python3 /shbr-echo.py
autostart=true
autorestart=true # автоматический перезапуск
stopasgroup=true
killasgroup=true
stdout_logfile=/var/log/supervisor/python.stdout.log # все логи складываем
stderr_logfile=/var/log/supervisor/python.stderr.log
root@58449305162e:/etc/supervisor/conf.d# 
```

У supervisor есть много опций. Можно посмотреть на все процессы, а с NOHUP, screen такого зделать было невозможно.

`cd /var/log/supervisor`

`ls`

```bash
java.stderr.log python.stderr.log supervisord.log
java.stdout.log python.stdout.log
```

`cat java.stdout.log` # запускаем log

      .   ____          _            __ _ _
     /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
    ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
     \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
      '  |____| .__|_| |_|_| |_\__, | / / / /
     =========|_|==============|___/=/_/_/_/
     :: Spring Boot ::                (v2.5.5)
    
    2022-08-15 12:05:39.563  INFO 8 --- [           main] ru.yandex.shbr.java.JavaApplication      : Starting JavaApplication using Java 17.0.1 on 58449305162e with PID 8 (/shbr-echo.jar started by root in /)
    2022-08-15 12:05:39.566  INFO 8 --- [           main] ru.yandex.shbr.java.JavaApplication      : No active profile set, falling back to default profiles: default
    2022-08-15 12:05:40.445  INFO 8 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 10000 (http)
    2022-08-15 12:05:40.455  INFO 8 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
    2022-08-15 12:05:40.456  INFO 8 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.53]
    2022-08-15 12:05:40.501  INFO 8 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
    2022-08-15 12:05:40.501  INFO 8 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 879 ms
    2022-08-15 12:05:40.768  INFO 8 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 10000 (http) with context path ''
    2022-08-15 12:05:40.776  INFO 8 --- [           main] ru.yandex.shbr.java.JavaApplication      : Started JavaApplication in 1.555 seconds (JVM running for 1.955)

У супервизора есть командная строка, процессами можем управлять как бы в процессе

`cd /var/log/supervisor`

`supervisorctl`

```bash
shbr-echo-java                   RUNNING   pid 8, uptime 0:17:06
shbr-echo-python                 RUNNING   pid 9, uptime 0:17:06
```

Например, можем остановить приложение:

`stop shbr-echo-java`

    shbr-echo-java: stopped

Выходим, проверяем, что приложение остановилось:

`exit`

`ps aux`

    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root           1  0.0  0.1  28428 23576 pts/0    Ss+  12:05   0:00 /usr/bin/python3 /usr/bin/supervisord
    root           9  0.0  0.1  41116 26320 pts/0    S    12:05   0:00 /usr/bin/python3 /shbr-echo.py
    root          46  0.0  0.0   4248  3616 pts/1    Ss   12:06   0:00 /bin/bash
    root          66  0.0  0.0   5900  2888 pts/1    R+   12:19   0:00 ps aux

Можем снова запустить:

`supervisorctl start shbr-echo-java`

    shbr-echo-java: started

`ps aux`

    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root           1  0.0  0.1  28428 23608 pts/0    Ss+  12:05   0:00 /usr/bin/python3 /usr/bin/supervisord
    root           9  0.0  0.1  41116 26320 pts/0    S    12:05   0:00 /usr/bin/python3 /shbr-echo.py
    root          46  0.0  0.0   4248  3616 pts/1    Ss   12:06   0:00 /bin/bash
    root          73 74.3  1.2 7917352 196928 pts/0  Sl   13:03   0:07 /usr/bin/java -jar /shbr-echo.jar
    root         109  0.0  0.0   5900  2924 pts/1    R+   13:03   0:00 ps aux

Если что-то убъет наше приложение

`kill -9 9` # убили приложение с PID 9

`ps aux`

    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root           1  0.0  0.1  28428 23608 pts/0    Ss+  12:05   0:00 /usr/bin/python3 /usr/bin/supervisord
    root          46  0.0  0.0   4248  3616 pts/1    Ss   12:06   0:00 /bin/bash
    root          73  2.7  1.2 7917352 197200 pts/0  Sl   13:03   0:07 /usr/bin/java -jar /shbr-echo.jar
    root         110  0.7  0.1  41112 26168 pts/0    S    13:08   0:00 /usr/bin/python3 /shbr-echo.py                # приложение перезапустилось с новым PID
    root         112  0.0  0.0   5900  2856 pts/1    R+   13:08   0:00 ps aux

Это событие можно увидеть в log:

`cat supervisord.log`

    2022-08-15 12:05:37,790 CRIT Supervisor is running as root.  Privileges were not dropped because no user is specified in the config file.  If you intend to run as root, you can set user=root in the config file to avoid this message.
    2022-08-15 12:05:37,790 INFO Included extra file "/etc/supervisor/conf.d/shbr.conf" during parsing
    2022-08-15 12:05:37,793 INFO RPC interface 'supervisor' initialized
    2022-08-15 12:05:37,794 CRIT Server 'unix_http_server' running without any HTTP authentication checking
    2022-08-15 12:05:37,794 INFO supervisord started with pid 1
    2022-08-15 12:05:38,797 INFO spawned: 'shbr-echo-java' with pid 8
    2022-08-15 12:05:38,799 INFO spawned: 'shbr-echo-python' with pid 9
    2022-08-15 12:05:40,445 INFO success: shbr-echo-java entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
    2022-08-15 12:05:40,445 INFO success: shbr-echo-python entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
    2022-08-15 12:18:42,558 INFO waiting for shbr-echo-java to stop
    2022-08-15 12:18:42,588 INFO stopped: shbr-echo-java (exit status 143)
    2022-08-15 13:03:44,670 INFO spawned: 'shbr-echo-java' with pid 73
    2022-08-15 13:03:46,086 INFO success: shbr-echo-java entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
    2022-08-15 13:08:15,717 INFO exited: shbr-echo-python (terminated by SIGKILL; not expected)                                                    # приложение остановлено SIGKILL
    2022-08-15 13:08:16,721 INFO spawned: 'shbr-echo-python' with pid 110                                                                        # приложение перезапущено
    2022-08-15 13:08:17,723 INFO success: shbr-echo-python entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)

Сам супервизор запускается в данном случае с помощью контейнера, на обычных linux-машинах systemd. 

Итого Супервизор - приложение на питоне, которое запускается и запускает другие приложения и следит за ними. Также оно слушает специальный определенный сокет, через который мы можем взаимодецствовать с приложением и управлять им. Опускать, поднимать приложения, который описан в config. 

#### Systemd

Systemd, аналог, Supervisor, только работает она на уровне системы и используется для загрузки непосредственно различных процессов
операционной системы, драйверов и т.д.

`cd 03-run-systemd`

Структура файлов:

`tree`

```bash
.
├── shbr-echo
│   ├── build
│   │   ├── build.sh
│   │   ├── clean.sh
│   │   ├── debian
│   │   │   ├── changelog
│   │   │   ├── compat
│   │   │   ├── control
│   │   │   └── rules
│   │   └── install.sh
│   ├── hint.sh
│   ├── java -> ../java
│   ├── python -> ../python
│   ├── shbr-echo-java.service
│   └── shbr-echo-python.service
└── Vagrantfile
```

`vagrant up` # запускаем vagrant

<img title="" src="file:///home/vibo/Pictures/GlobalMarkText/2022-08-19-22-10-12-image.png" alt="" data-align="center">

У меня не запустился c ошибкой 404:

```bash
Bringing machine '03-run-systemd' up with 'virtualbox' provider...
==> 03-run-systemd: Box 'ubuntu/focal64' could not be found. Attempting to find and install...
    03-run-systemd: Box Provider: virtualbox
    03-run-systemd: Box Version: >= 0
The box 'ubuntu/focal64' could not be found or
could not be accessed in the remote catalog. If this is a private
box on HashiCorp's Vagrant Cloud, please verify you're logged in via
`vagrant login`. Also, please double-check the name. The expanded
URL and error message are shown below:

URL: ["https://vagrantcloud.com/ubuntu/focal64"]
Error: The requested URL returned error: 404
```

`ps aux` # вывод всех процессов

Во всех современных дистрибутивах, для управления процессами можно встретить Systemd. Давайте посмотрим, как это выглядит. 

`systemctl -a`             # выводит запущенные сервисы

В папке shbr-echo, вместо config как в Supervisor, используется описание сервиса systemd. Синтаксис похож на config supervisor, только другие секции.

Файл shbr-echo-java.service:

```bash
[Unit]
Description=shbr-echo-java
After=network-online.target

[Service]
Type=simple # тип запуска simple
ExecStart=/usr/bin/java -jar /usr/bin/shbr-echo.jar # команда запуска

[Install]
WantedBy=multi-user.target
```

shbr-echo-python.service:

```bash
[Unit]
Description=shbr-echo-python
After=network-online.target

[Service]
Type=simple # тип запуска
ExecStart=/usr/bin/python3 /usr/bin/shbr-echo.py # команда запуска 

[Install]
WantedBy=multi-user.target
```

Также, помимо simple, есть и другие типы запуска, например, если приложение умеет само демонизироваться и писать свой индентификатор процессов в специальные PID-файлы и systemd следит за ними отдельными способами.

Попробуем запустит наши приложения в systemd. Вернемся опять к deb-пакетам. Т.е. у нас сейчас здесь нет докера и наша задача вместе с пакетом привести в систему знания о том, как пакет нужно запустить. Чтобы это сделать к нашему install.sh нужно сделать следующее:

```bash
#!/bin/bash
set -e

mkdir -p "$DESTDIR/usr/bin/"
mkdir -p "$DESTDIR/etc/systemd/system/" # эта строчка

cp libs/java-0.0.1-SNAPSHOT.jar "$DESTDIR/usr/bin/shbr-echo.jar"
cp main.py "$DESTDIR/usr/bin/shbr-echo.py"
cp ../shbr-echo-java.service "$DESTDIR/etc/systemd/system/" # эта строчка
cp ../shbr-echo-python.service "$DESTDIR/etc/systemd/system/" # эта строчка
```

При сборке пакета мы точно также как и в докер-контейнерах раскладываем наши файлы по системе, как они и должны там лежать. Соответственно описание sustemd сервисов  лежат в etc/systemd/system. Есть еще много разных дирректорий для установки, но для нашего пакета эта дирректирия подходящая. Далее помимо копирования папки с кодом (shbr-echo) мы также довозим в нашу систему сервис-файлы и копируем их в etc/systemd/system.

Также в debisn/rules нам нужно дописать --with systemd, как показано ниже.

```bash
#!/usr/bin/make -f

PKGDIR=debian/tmp

%:
    dh $@ --with systemd # вот здесь

override_dh_auto_clean:
    ./clean.sh

override_dh_auto_build:
    ./build.sh

override_dh_auto_install:
    env DESTDIR=debian/shbr-echo ./install.sh
```

Зачем нужен флаг --with systemd. Когда мы кладем новый файл на файловую систему - systemd не видит эти файлы. Т.е. он один раз считал файлы в свою базу и с ними работает,  а если мы обновили файлы - нам нужно сообщить системе, что файл добавился, удалился или поменялся. Для этого есть команда `sudo systemctl daemon-reload`. Когда мы дописываем флаг --with systemd опция sudo systemctl daemon-reload происходит автоматически.

В папке build из под vagrant запускаем следующую команду для сборки пакета  :

`dpkg-buildpackage -b --no-sign`

`sudo dpkg -i shbr-echo_1.0.0-1_amd64.deb`

`systemctl -a | grep -C 5 shbr`

Теперь видим, как в systemctl появился наш сервис, проверяем:

`cat shbr-echo-java.service`

`systemctl status shbr-echo-java`

Видно, что вместе с пакетом приехал наш сервис, но он не запущен. А чтобы запустить надо сделать старт от root.

`sudo systemctl start shbr-echo-java`

`curl -v http://localhost:10000/hello`

Все работает, приложение отвечает.

#### Docker

`cd 03-run-docker`

`ls`

    Dockerfile  Makefile

cat Makefile

```bash
docker-build:
    docker build -t cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-docker:latest .

docker-run:
    docker run -e LANG=java -e PREFIX="Hello, " -d --name shbr-03-run-docker -p 10000:10000 cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-docker:latest

docker-push:
    docker push cr.yandex/crpamim8dasm0u97qtpf/shbr-03-run-docker:latest%    
```

`make docker-run` # запускаем контейнер

`curl http://localhost:10000/world`# вызываем приложение

    Hello, world%

`curl -v http://localhost:10000/world` # еще раз с подробной информацией

```bash
*   Trying 127.0.0.1:10000...
* Connected to localhost (127.0.0.1) port 10000 (#0)
> GET /world HTTP/1.1
> Host: localhost:10000
> User-Agent: curl/7.84.0
> Accept: */*
> 
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 
< X-Shbr-Lang: java
< Content-Type: text/plain;charset=UTF-8
< Content-Length: 12
< Date: Mon, 15 Aug 2022 13:45:55 GMT
< 
* Connection #0 to host localhost left intact
Hello, world%     
```

`docker inspect 652d3444d47c`# просмотр информации о контейнере, где и какие переменные окружения прописаны, дирректории.

```json
[
    {
        "Id": "ee5f5d18cfd374821999e778948c0103c0208baee6a78754f0583d5a0f03c195",
        "Created": "2022-08-19T20:16:43.387522971Z",
        "Path": "/entrypoint.sh",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 31962,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2022-08-19T20:16:43.739975638Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
...

                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.5",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:05",
                    "DriverOpts": null
                }
            }
        }
    }
```

У докера есть множество флагов, они вызываются `docker run --help`:

```
Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

Run a command in a new container

Options:
...
      --oom-kill-disable               Disable OOM Killer
...
```

В докере можно задавать много разных параметров. Например,  выключать киллер памяти`--oom-kill-disable`,  ограничивать количество файловых дискриптеров . Также есть отдельные политики, если приложение упадет, т.е. можно его можно перезапустить, а можно не ерезапускать.

Все, что мы сделали с докер - мы сделаи руками. Почему плохо запускать приложения руками:

- все забывается;
- сложно делить знания о системе с командой;
- много рутины;
- физически невозможно управлять большим количеством машин.

Чтобы не работать руками используем SCM (система управления конфигурацией), например, **ansible**.

#### Ansible

На примере ansible посмотрим, как избавиться от рутины по запуску сервисов. Это базовый обзор для ознакомления.

`cd 03-run-ansible`
`ls`                                                               

```bash
inventory  Makefile  playbook.yaml  README.md  requirements.txt
```

`ls -la`                                                           

```bash
total 24
drwxrwxr-x 1 vibo vibo 130 Aug 11 18:22 .
drwxr-xr-x 1 vibo vibo 538 Aug 15 17:02 ..
-rw-rw-r-- 1 vibo vibo   3 Aug 11 18:22 .gitignore
-rw-rw-r-- 1 vibo vibo   9 Aug 11 18:22 inventory # список серверов, которые хотим конфигурировать
-rw-rw-r-- 1 vibo vibo 117 Aug 11 18:22 Makefile
-rw-rw-r-- 1 vibo vibo 351 Aug 11 18:22 playbook.yaml # что нужно делать
-rw-rw-r-- 1 vibo vibo 338 Aug 11 18:22 README.md
-rw-rw-r-- 1 vibo vibo  32 Aug 11 18:22 requirements.txt
```

Минимально для конфигурирования ansible нужно два файла: inventory и playbook.yaml.

##### Файл inventory

В inventory перечисляются все ваши хосты, которые мы хотим конфигурировать.

`cat inventory` 

    localhost%  

Можно написать отдельный список, и с помощью специальных палагинов его устанавиливать.

##### Файл playbook

В файле playbook описывается непосредственно то, что нужно сделать. И описывается последовательно.

`cat playbook.yaml`

```bash
- hosts: "all" # на все хосты из inventory
  connection: local # не используя ssh, локально выполнить таски
  tasks:
    - name: "shbr-echo : container"
      docker_container:
        name: "shbr-03-run-ansible"
        restart_policy: 'always'
        state: 'started'
        image: 'cr.yandex/crpamim8dasm0u97qtpf/shbr-01-package-docker:latest'
        env:
          LANG: java
        ports:
          - "10000:10000"
```

В тасках есть два основных поля: name - название задачи и дальше назавание плагина, который нужно использовать. Далее мы описываем с какми опциями мы запускаем контейнер. Соответсвенно этот файлик можно хранить в гитхабе, шарить с командой и ничего не потеряется.

`cat Makefile`

    play:
        ANSIBLE_PYTHON_INTERPRETER=$$(pwd)/env/bin/python $$(pwd)/env/bin/ansible-playbook -i inventory playbook.yaml

Чтобы заработало (README.md):

1. Создаем virtualenv: `virtualenv env`
2. Активируем: `source env/bin/activate`
3. Ставим зависимости: `pip install -r requirements.txt`
4. Запускаем: `make play`

`make play` # запускаем ansible

```bash
PLAY [all] *********************************************************************

TASK [Gathering Facts] *********************************************************
ok: [localhost]

TASK [shbr-echo : container] ***************************************************
[DEPRECATION WARNING]: The container_default_behavior option will change its 
default value from "compatibility" to "no_defaults" in community.docker 2.0.0. 
To remove this warning, please specify an explicit value for it now. This 
feature will be removed from community.docker in version 2.0.0. Deprecation 
warnings can be disabled by setting deprecation_warnings=False in ansible.cfg.
changed: [localhost]

PLAY RECAP *********************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
```

Gathering Facts - это этап, который выполняется для сбора различных фактов о машине. Под фактом понимается количество ядер, какая операционная система. Далее выполнился наш TASK, который поднял нам докер контейнер. Запустился докер-контейнер, который мы описали в ansimble.

### Вопросы после модуля:

Systemctl - это утилита для управления systemd. Supervisor - это приложение, которое мы запустили сами и он очень легковесный. Supervisor можно использовать внутри докер-контейнера, если вам нужно запустить несколько процессов в одном докер-контейнере. Это раочая схема и иногда так приходится делать. А вот systemd внутри контейнера - нетривиальное, а главное для production плохое решение. 

Если запускать на голом линуксе - предпочтительнее systemd, если контейнерна установка - supervisor.

Docker compose -  запускает несколько контейнеров, которые нам укажет. Ansible - система в которой мы также декларируем задачи и дальше ansible сам подключатеся по ssh к радным машинам и выполняет команды, которые мы описали. Docker compose так не умеет, он просто подключается кодеру и поднимает там контейнер.
